# Game of Pure Strategy

Strategy optimizer / Nash equilibrium finder for the Game of Pure Strategy (Goofspiel).

This is a Python reproduction of *Rhoads, G. C.; Bartholdi, L. (2012). "Computer Solution to the Game of Pure Strategy".
Games. 3 (4): 150â€“156*, which can be found [here (implementation & key results)](http://gcrhoads.byethost4.com/gops.html)
and [here (entire article)](https://www.econstor.eu/obitstream/10419/98554/1/749748680.pdf).

The aim of this reproduction is to provide a more readable version of the algorithm for solving the game
(finding the Nash equilibrium for a given game size).

The resulting payoff and strategy matrices exactly match the ones generated by the
original implementation, while the implementation is in my opinion much more readable
(it is more than **4x shorter** and written in modern Python, as opposed to legacy C++).

Being implemented in Python, it uses the [Python-MIP](https://www.python-mip.com/) package
with CBC solver to solve linear problems (as opposed to GLPK used in the original implementation).


## About the game

According to [Wikipedia](https://en.wikipedia.org/wiki/Goofspiel):
> Goofspiel is played using cards from a standard deck of cards, and is typically a two-player game,
although more players are possible. Each suit is ranked A (low = 1), 2, ..., 10, J, Q, K (high = 13).
>
> One suit is singled out as the "prizes"; each of the remaining suits becomes a hand for one player,
with one suit discarded if there are only two players, or taken from additional decks if there are four or more.
The prizes are shuffled and placed between the players with one card turned up.
>
> Play proceeds in a series of rounds. The players make "closed bids" for the top (face up) prize
by selecting a card from their hand (keeping their choice secret from their opponent).
Once these cards are selected, they are simultaneously revealed, and the player making the highest bid
takes the competition card.
>
> Rules for ties in the bidding vary, possibilities including the competition card being discarded,
or its value split between the tied players (possibly resulting in fractional scores).
Some play that the current prize may "roll over" to the next round, so that two or more cards
are competed for at once with a single bid card.
>
> The cards used for bidding are discarded, and play continues with a new upturned prize card.
>
> After 13 rounds, there are no remaining cards and the game ends. Typically, players earn points
equal to sum of the ranks of cards won (i.e. Ace is worth one point, 2 is two points, etc.,
Jack being worth 11, Queen 12, and King worth 13 points). Players may agree upon other scoring schemes.

The implementation solves the game for a given number of cards *N*, and assumes that
in case of a tie neither of the players get the prize. Moreover, assumes optimal strategy
tries to maximize the total value of cards won by player over the opponent, rather than
the probability of having greater total value of cards than the opponent.


## Comparison to original implementation

This implementation uses the following optimizations described in the paper:
- dynamic programming (instead of recursive algorithm)
- symmetry (to solve only half of the linear programs)

With these optimizatons, it is possible to compute values for `N=1,...,7`
under 3 minutes on a normal laptop (and `N=8` under 30 minutes).

That said, this implementation is still significantly slower than the original one,
but with some small improvements the speed should be easily matched:
- finding saddle points for `N=2` (currently, we don't distinguish them from `N>2`)
- compiling repeatedly called parts of code with [numba](http://numba.pydata.org/)
- using numpy to represent matrices (currently, we use a simple dict)
- using multiprocessing
- computing only a hash of game state continuation during queries to the cache
  (currently, we compute entire states which is a big waste of memory)

I focused on code readability over performance, as generating results for `N=5,6,7`
was enought for my project.


## Experimental results

The Game of Pure Strategy is a zero-sum game, with optimal strategy always
being the same for both players (strategy is represented by probability of playing
given card when a given top card is revealed). Therefore, the expected value
of the game (player score - opponent score) in the Nash equilibrium is always zero.

Depending on the size of the game (number of cards, each assigned value from 1 to N),
the optimal strategies differ significantly, without a known pattern.

Execution times reported below are based on experiments running on MacBook Pro
(13-inch, 2019, 1,7 GHz Quad-Core Intel Core i7, 16 GB 2133 MHz LPDDR3).


### Small games: N=1,2,3

For small N results are trivial - play the same card as the one revealed from the deck.

N=1:

|   top card \ player move |      1 |
|--------------------------|--------|
|                        1 | 1.0000 |

N=2:

|   top card \ player move |      1 |      2 |
|--------------------------|--------|--------|
|                        1 | 1.0000 | 0.0000 |
|                        2 | 0.0000 | 1.0000 |

N = 3:

|   top card \ player move |      1 |      2 |      3 |
|--------------------------|--------|--------|--------|
|                        1 | 1.0000 | 0.0000 | 0.0000 |
|                        2 | 0.0000 | 1.0000 | 0.0000 |
|                        3 | 0.0000 | 0.0000 | 1.0000 |


### N = 4

This is the smaller size for which we reach interesting conclusions about optimal
strategies - for example, we should always play 4 against 4 revealed from the deck,
and 1 against 1, but for 2 and 3 this isn't that easy anymore.

|   top card \ player move |      1 |      2 |      3 |      4 |
|--------------------------|--------|--------|--------|--------|
|                        1 | 1.0000 | 0.0000 | 0.0000 | 0.0000 |
|                        2 | 0.3371 | 0.1360 | 0.5269 | 0.0000 |
|                        3 | 0.2687 | 0.0000 | 0.5140 | 0.2173 |
|                        4 | 0.0000 | 0.0000 | 0.0000 | 1.0000 |

Time: `0.67s user 0.15s system 98% cpu 0.834 total`


### N = 5

At this point, we start seeing that if revealed card is not the top one, we should
never play the same one. For games of this size, the optimal strategy is to bet
1 higher than the revealed card, but this should not be done in a deterministic way
(since any deterministic strategy can be easily exploited by the opponent,
as discussed in the original paper).

|   top card \ player move |      1 |      2 |      3 |      4 |      5 |
|--------------------------|--------|--------|--------|--------|--------|
|                        1 | 0.0470 | 0.8327 | 0.1203 | 0.0000 | 0.0000 |
|                        2 | 0.1855 | 0.0000 | 0.7375 | 0.0770 | 0.0000 |
|                        3 | 0.1182 | 0.1188 | 0.0000 | 0.7630 | 0.0000 |
|                        4 | 0.1226 | 0.0735 | 0.1915 | 0.2043 | 0.4081 |
|                        5 | 0.1123 | 0.0241 | 0.0000 | 0.0000 | 0.8636 |

Time: `2.07s user 0.29s system 99% cpu 2.378 total`


### N = 6

From this step on, the pattern discovered for size 5 is no longer relevant.
In fact, it is extremely hard to find any pattern that holds for larger games.

Detailed analysis of larger patterns is available with the original implementation.
I still ran some of the larger examples, mostly to check how this implementation performs
in comparison to the original one, and the results are available below.

|   top card \ player move |      1 |      2 |      3 |      4 |      5 |      6 |
|--------------------------|--------|--------|--------|--------|--------|--------|
|                        1 | 0.1650 | 0.5774 | 0.2576 | 0.0000 | 0.0000 | 0.0000 |
|                        2 | 0.0000 | 0.3253 | 0.1814 | 0.4933 | 0.0000 | 0.0000 |
|                        3 | 0.0655 | 0.1315 | 0.1700 | 0.2907 | 0.3424 | 0.0000 |
|                        4 | 0.0980 | 0.0458 | 0.1734 | 0.0000 | 0.6081 | 0.0746 |
|                        5 | 0.0273 | 0.0864 | 0.0000 | 0.3461 | 0.0202 | 0.5200 |
|                        6 | 0.0000 | 0.1383 | 0.0062 | 0.0000 | 0.0000 | 0.8554 |

Time: `14.33s user 1.43s system 99% cpu 15.835 total`

Logs from execution:
```log
INFO: Calculating strategies for n_cards=1
INFO: Calculated strategies for n_cards=1 in 0.00s
INFO: Calculating strategies for n_cards=2
INFO: Calculated strategies for n_cards=2 in 1.89s
INFO: Calculating strategies for n_cards=3
INFO: Calculated strategies for n_cards=3 in 7.50s
INFO: Calculating strategies for n_cards=4
INFO: Calculated strategies for n_cards=4 in 5.33s
INFO: Calculating strategies for n_cards=5
INFO: Calculated strategies for n_cards=5 in 0.52s
INFO: Calculating strategies for n_cards=6
```


### N = 7

|   top card \ player move |      1 |      2 |      3 |      4 |      5 |      6 |      7 |
|--------------------------|--------|--------|--------|--------|--------|--------|--------|
|                        1 | 0.2431 | 0.4017 | 0.3552 | 0.0000 | 0.0000 | 0.0000 | 0.0000 |
|                        2 | 0.0000 | 0.4301 | 0.0066 | 0.5633 | 0.0000 | 0.0000 | 0.0000 |
|                        3 | 0.1230 | 0.0000 | 0.3082 | 0.0000 | 0.5688 | 0.0000 | 0.0000 |
|                        4 | 0.0100 | 0.1078 | 0.0000 | 0.3614 | 0.0278 | 0.4929 | 0.0000 |
|                        5 | 0.0000 | 0.1017 | 0.0000 | 0.2678 | 0.0310 | 0.3863 | 0.2132 |
|                        6 | 0.0513 | 0.0264 | 0.1039 | 0.0000 | 0.3153 | 0.0000 | 0.5032 |
|                        7 | 0.0632 | 0.0010 | 0.1084 | 0.0395 | 0.0000 | 0.0000 | 0.7880 |

Time: `125.26s user 11.08s system 99% cpu 2:16.88 total`

Logs from execution:
```log
INFO: Calculating strategies for n_cards=1
INFO: Calculated strategies for n_cards=1 in 0.00s
INFO: Calculating strategies for n_cards=2
INFO: Calculated strategies for n_cards=2 in 5.19s
INFO: Calculating strategies for n_cards=3
INFO: Calculated strategies for n_cards=3 in 39.66s
INFO: Calculating strategies for n_cards=4
INFO: Calculated strategies for n_cards=4 in 67.68s
INFO: Calculating strategies for n_cards=5
INFO: Calculated strategies for n_cards=5 in 22.35s
INFO: Calculating strategies for n_cards=6
INFO: Calculated strategies for n_cards=6 in 1.22s
INFO: Calculating strategies for n_cards=7
```


### N = 8

Results:

|   top card \ player move |      1 |      2 |      3 |      4 |      5 |      6 |      7 |      8 |
|--------------------------|--------|--------|--------|--------|--------|--------|--------|--------|
|                        1 | 0.3094 | 0.2499 | 0.4407 | 0.0000 | 0.0000 | 0.0000 | 0.0000 | 0.0000 |
|                        2 | 0.0055 | 0.2216 | 0.1643 | 0.3437 | 0.2648 | 0.0000 | 0.0000 | 0.0000 |
|                        3 | 0.1273 | 0.0000 | 0.2509 | 0.0788 | 0.3555 | 0.1874 | 0.0000 | 0.0000 |
|                        4 | 0.0000 | 0.1160 | 0.0000 | 0.2943 | 0.0324 | 0.3915 | 0.1657 | 0.0000 |
|                        5 | 0.0764 | 0.0008 | 0.1355 | 0.0000 | 0.2987 | 0.0000 | 0.4885 | 0.0000 |
|                        6 | 0.0325 | 0.0000 | 0.1456 | 0.0085 | 0.1991 | 0.0792 | 0.2982 | 0.2369 |
|                        7 | 0.0000 | 0.0676 | 0.0000 | 0.1609 | 0.0176 | 0.2147 | 0.0000 | 0.5391 |
|                        8 | 0.0000 | 0.0482 | 0.0000 | 0.1479 | 0.0000 | 0.0000 | 0.0000 | 0.8039 |

Time: `1167.87s user 138.14s system 99% cpu 21:52.30 total`

Logs from execution:
```log
INFO: Calculating strategies for n_cards=1
INFO: Calculated strategies for n_cards=1 in 0.00s
INFO: Calculating strategies for n_cards=2
INFO: Calculated strategies for n_cards=2 in 11.44s
INFO: Calculating strategies for n_cards=3
INFO: Calculated strategies for n_cards=3 in 171.84s
INFO: Calculating strategies for n_cards=4
INFO: Calculated strategies for n_cards=4 in 574.48s
INFO: Calculating strategies for n_cards=5
INFO: Calculated strategies for n_cards=5 in 468.92s
INFO: Calculating strategies for n_cards=6
INFO: Calculated strategies for n_cards=6 in 80.13s
INFO: Calculating strategies for n_cards=7
INFO: Calculated strategies for n_cards=7 in 2.92s
INFO: Calculating strategies for n_cards=8
```


## Using the project

You need `Python>=3.7` to use this project.

Install:
```shell
pip install https://github.com/kowaalczyk/game-of-pure-strategy/releases/download/0.2.0/game_of_pure_strategy-0.2.0-py3-none-any.whl
```

Run using CLI:
```shell
gops --help  # see all available options
gops -n 3  # optimize strategy for N=3
gops -n 3 --log-level=DEBUG  # run more logs (printed to stderr)
gops -n 3 --log-level=ERROR  # run without logs
```

Use in python shell / another application:
```python
# available classes:
from game_of_pure_strategy import (
    Strategy,
    optimize_player_strategy,
    get_strategies_for_possible_top_cards,
    get_optimal_game_strategy,
    visualize_strategies,
)

# get a dict mapping top card (int) -> strategy (instance of Strategy dataclass):
strategies = get_optimal_game_strategy(game_size=3)
for game_size, startegy in strategies.items():
    print(game_size, strategy.expected_value)

# print a table with summary of results (like the one you can see from CLI):
print(visualize_strategies(strategies))
```


## Development setup

For development, you need `Python>=3.7` and poetry (`pip install poetry` if you don't have it yet).

After cloning the repository, you can use poetry commands to perform basic tasks:
- `poetry install` to install all dependencies
- `poetry run pytest .` to run all tests
- `poetry run flake8 .` to check formatting
- `poetry run black .` to auto-format entire project

The python package is built automatically for pull requests to master branch,
using `poetry build -f wheel`.
